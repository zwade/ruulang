use crate::parser::slang_ast::{Rule, Attribute, Entrypoint};

grammar;

match {
    r"//[^\n\r]*[\n\r]*" => { },
} else {
    r"\s*" => { },
    _ // Everything else
}

pub Term: Vec<Entrypoint> = {
    <e: (<Entry>)*> => e
};

pub Entry: Entrypoint = {
    "@" <s:Symbol> "{" <r: (<Rule>)*> "}" => Entrypoint { entrypoint: s, rules: r },
}

pub Rel: Rule = {
    <s:Symbol> <a: (<Attr>)*> "{" <r: (<Grant> ";")*> <c: (<Rule>)*> "}" => Rule { relationship: s, attributes: a, grants: r, rules: c, recursive: false },
}

pub Uni: Rule = {
    <s:Symbol> <a: (<Attr>)*> "{" "*" "}" => Rule {
        relationship: s,
        attributes: a,
        grants: vec![vec!["read".to_string()], vec!["write".to_string()]],
        rules: vec![Rule {
            relationship: "*".to_string(),
            attributes: vec![],
            grants: vec![vec!["read".to_string()], vec!["write".to_string()]],
            rules: vec![],
            recursive: true,
        }],
        recursive: false,
    }
}

pub Rule: Rule = {
    <r: Rel> => r,
    <u: Uni> => u,
}

pub Attr: Attribute = {
    ":" <s:Symbol> "(" <a: (<Symbol>)*> ")" => Attribute { name: s, arguments: a },
    ":" <s:Symbol> => Attribute { name: s, arguments: vec![] },
}

pub Grant: Vec<String> = {
    <s: Symbol> <sp: ("." <Symbol>)*> => {
        let mut vec = vec![s];
        vec.extend(sp);
        vec
    }
}

Symbol: String = <s:r"[a-zA-Z][a-zA-Z0-9-_]*"> => s.to_string();
