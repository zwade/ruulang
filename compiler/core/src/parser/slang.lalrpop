use crate::parser::{
    slang_ast::{Rule, Attribute, Entrypoint, Fragment},
    parser_constructs::{ParserStatement}
};

grammar;

match {
    r"//[^\n\r]*[\n\r]*" => { },
    r"/\*[^*]*\*+(?:[^/*][^*]*\*+)*/" => { },
} else {
    r"\s*" => { },
    _ // Everything else
}

pub Term: Vec<ParserStatement> = {
    <e: (<Entry>)*> => e
};

pub Entry: ParserStatement = {
    <f:Frag> => ParserStatement::Fragment(f),
    "@" <s:Symbol> "{" <r: (<Rule>)*> "}" => ParserStatement::Entrypoint(
        Entrypoint { entrypoint: s, rules: r }
    ),
}

pub Frag: Fragment = {
    "fragment" <s:Symbol> "{" <r: (<Grant> ";")*> <c: (<Rule>)*> "}" => Fragment { name: s, grants: r, rules: c },
}

pub Rel: Rule = {
    <s:Symbol> <a: (<Attr>)*> "{" <r: (<Grant> ";")*> <f: ("#" <Symbol> ";")*> <c: (<Rule>)*> "}" => Rule { relationship: s, attributes: a, grants: r, rules: c, include_fragments: f, recursive: false },
}

pub Uni: Rule = {
    <s:Symbol> <a: (<Attr>)*> "{" "*" "}" => Rule {
        relationship: s,
        attributes: a,
        grants: vec![vec!["read".to_string()], vec!["write".to_string()]],
        rules: vec![Rule {
            relationship: "*".to_string(),
            attributes: vec![],
            grants: vec![vec!["read".to_string()], vec!["write".to_string()]],
            rules: vec![],
            recursive: true,
            include_fragments: vec![],
        }],
        include_fragments: vec![],
        recursive: false,
    }
}

pub Rule: Rule = {
    <r: Rel> => r,
    <u: Uni> => u,
}

pub Attr: Attribute = {
    ":" <s:Symbol> "(" <a: (<Symbol>)*> ")" => Attribute { name: s, arguments: a },
    ":" <s:Symbol> => Attribute { name: s, arguments: vec![] },
}

pub Grant: Vec<String> = {
    <s: Symbol> <sp: ("." <Symbol>)*> => {
        let mut vec = vec![s];
        vec.extend(sp);
        vec
    }
}

Symbol: String = <s:r"[a-zA-Z][a-zA-Z0-9-_]*"> => s.to_string();
